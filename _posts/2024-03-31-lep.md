---
title: List Encapsulation Pattern
---
# Améliorez la maintenabilité de votre code java avec le pattern LEP
Dans le monde du développement logiciel, la bonne conception du code est essentielle pour assurer la maintenabilité à long terme. Pour ce premier article, je vais vous présenter une pratique simple, mais puissante que j'ai nommée le **LEP** pour **List Encapsulation Pattern**. Cette pratique vise à encapsuler les listes de données dans des classes dédiées pour améliorer la gestion et la réutilisabilité du code.

## Pourquoi un Pattern ?
Martin Folwer explique
[sur son site](https://www.martinfowler.com/bliki/POJO.html)
que les patterns sont plus populaires lorsqu'on leur donne un nom sympa. En nommant cette pratique LEP, nous pouvons mieux communiquer sur celle-ci et encourager son adoption.

## Illustration du Problème
Pour comprendre l'importance du LEP, considérons un exemple concret. Imaginons que nous ayons une application qui nécessite de trouver l'article le moins cher de tous les articles. Initialement, nous pourrions implémenter cette fonctionnalité de la manière suivante :
```java
public record Item(double price) {
}

public interface ItemRepository {
    List<Item> findAll();
}

public class ItemService {
    
    private final ItemRepository repository;
    
    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        return findCheapest(repository.findAll());
    }

    private Optional<Item> findCheapest(List<Item> items) {
        return items.stream().min(Comparator.comparing(Item::price));//Ici on recherche l'article le moins cher de la liste
    }
}
```

A priori on ne voit pas de problème. Le code est concis, clair et *(presque)* testable. Imaginons maintenant que l'on veuille introduire des paniers d'achats contenant des articles. Cette nouvelle notion peut être représentée par une nouvelle classe appelée `ShoppingCart` :
```java
public record ShoppingCart(List<Item> items) {
}
```

Si on souhaite trouver l'article le moins cher de ce panier en réutilisant le code existant, il faut :
* Ajouter une nouvelle méthode `findCheapestItem()` dans la classe `ShoppingCart` en se basant sur un objet `ItemService`.
* Instancier un objet `ItemService` pour appeler la méthode dont on a besoin.
* Rendre publique la méthode `private Optional<Item> findCheapest(List<Item> items)` de la classe `ItemService`.

On obtient alors le code suivant :
```java
public record ShoppingCart(List<Item> items) {

    public Optional<Item> findCheapestItem() {
        return new ItemService(null).findCheapest(items);
    }
}
```

On se rend compte que le code n'est pas clair. Le constructeur de `ItemService` a besoin d'un `ItemRepository`, mais la méthode `findCheapest` que nous souhaitons appeler n'en a pas besoin. On passe donc un objet `ItemRepository` à `null` pour instancier l'objet `ItemService`. Tout cela pour simplement appeler la méthode `findCheapest`.

Bref, tous ces efforts pour ce résultat peut pousser les développeurs à se pencher vers cette autre solution :
```java
public record ShoppingCart(List<Item> items) {

    public Optional<Item> findCheapestItem() {
        return items.stream().min(Comparator.comparing(Item::price));
    }
}
```

Un bon `Ctrl+C` `Ctrl+V` (ce qui n'est guère mieux). Étant donné qu'il ne s'agit que d'une seule ligne de code, la duplication ne sera pas même pas détectée par les outils d'analyse de code. Pourtant il y a bien un problème de conception ici.

## Solution avec le Pattern LEP

Le LEP propose une solution simple et efficace à ce problème. En encapsulant la liste d'articles dans une classe dédiée, le code devient plus modulaire, plus réutilisable et plus facile à maintenir. Voici comment nous pourrions réécrire notre exemple en utilisant le LEP :
```java
public record Item(double price) {
}

//Cette nouvelle classe encapsule la liste des articles et expose une méthode de recherche de l'article le moins cher
public record Items(List<Item> items) {

    public Optional<Item> findCheapest() {
        return items.stream().min(Comparator.comparing(Item::getPrice));
    }
}

//Le panier d'articles se compose maintenant des Items à la place d'une List<Item>
public record ShoppingCart(Items items) {

    public Optional<Item> findCheapestItem() {
        return items.findCheapest();//L'appel vers le code existant est plus naturel
    }
}

public interface ItemRepository {
    Items findAll();//Le recherche retourne maintenant des Items au lieu d'une List<Item>
}

public class ItemService {

    private final ItemRepository repository;

    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        return repository.findAll().findCheapest();//La recherche n'est plus implémentée dans ce service
    }
}
```

## Avantages du Pattern LEP

En adoptant le LEP, nous bénéficions donc de plusieurs avantages :

* **Modularité** : La logique de traitement est encapsulée dans des classes dédiées, ce qui rend le code plus modulaire et plus facile à comprendre.
* **Réutilisabilité** : Les fonctionnalités encapsulées peuvent être réutilisées facilement dans d'autres parties de l'application.
* **Maintenabilité** : En centralisant la logique de traitement, le code devient plus facile à tester et donc à maintenir.

Un point très important et que ce pattern peut être **introduit progressivement** dans un projet car on peut facilement faire des conversions entre `Items` et `List<Items>` comme ceci :
* `List<Item> itemList = items.items();`
* `Items items = new Items(itemList);`

## Conclusion
Le **List Encapsulation Pattern** est donc une pratique simple, mais puissante pour améliorer notre code Java. En encapsulant les listes dans des classes dédiées, nous pouvons rendre notre code plus modulaire, plus réutilisable et plus facile à maintenir. Je vous encourage donc à adopter cette pratique dans vos propres projets de développement pour en récolter les bénéfices à long terme.
