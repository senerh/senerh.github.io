---
title: List Encapsulation Pattern
---
<!---
https://gist.github.com/rxaviers/7360908
-->
Bonjour !

Pour mon tout premier article j'ai décidé de vous parler d'un pattern que j'ai nommé **LEP** pour **List Encapsulation Pattern**. Derrière cet acronymme se cache en réalité un concept très simple à comprendre et à adopter. D'ailleurs il est tout à fait possible que ce soit quelque chose que vous appliquiez déjà, mais visiblement [les patterns sont plus populaire lorsqu'on leur donne un nom sympa](https://fr.wikipedia.org/wiki/Plain_old_Java_object#Description) donc c'est ce que j'ai essayé de faire. Après est-ce que ce nom est sympa ? Je vous laisserai juger :smile:

Comme tout *bon* développeur java, j'utilise les `Collection` et les `stream` au quotidien pour le traitement de mes données. Je vais vous montrer à travers un exemple comment implémenter des traitements sur une `List` d'abord sans, puis ensuite avec le pattern LEP.

## Ennoncé : 
On considère les trois classes ci-dessous :
```java
/**
 * Représente un article
 */
public interface Item {
    BigDecimal getPrice();
}

/**
 * Permet de récupérer les articles
 */ 
public interface ItemRepository {
    List<Item> findAll();
}

/**
 * Expose des services en rapport avec les articles
 */
public class ItemService {
    
    private final ItemRepository repository;
    
    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        //TODO - implémenter la recherche de l'article le moins cher
    }
}
```

On souhaite implémenter la méthode `findCheapest()` de la classe `ItemService` en respectant les deux consignes suivantes :
* ne pas modifier les classes `Item` et `ItemRepository`
* écrire des tests unitaires couvrant le nouveau code à 100%


## Première solution : ce qu'il ne faut pas faire
La première solution qui pourrait nous venir à l'esprit est une implémentation semblable à celle-ci :

```java
public class ItemService {
    
    private final ItemRepository repository;
    
    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public BigDecimal findCheapest() {
        return repository.findAll()
            .stream()
            .min(Comparator.comparing(Item::getPrice));
    }
}
```

Cela fonctionne, mais 

### Service
### Utils/Helper

## LEP
```java
public class Items {
    
    private final List<Item> items;
    
    public ItemService(List<Item> items) {
        this.items = items;
    }

    public Optional<Item> findCheapest() {
        return items.stream().min(Comparator.comparing(Item::getPrice));
    }
}
```

```java
public class ItemService {
    
    private final ItemRepository repository;
    
    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        return new Items(repository.findAll()).findCheapest();
    }
}
```

## Les tests

## Comment l'adopter ?

## Conclusion

