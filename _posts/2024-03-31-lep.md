---
title: List Encapsulation Pattern
---
<!---
https://gist.github.com/rxaviers/7360908
-->
Bonjour !

Pour mon tout premier article j'ai décidé de vous parler d'un pattern que j'ai nommé **LEP** pour **List Encapsulation Pattern**. Derrière cet acronymme se cache en réalité un concept très simple à comprendre et à adopter. D'ailleurs il est tout à fait possible que ce soit quelque chose que vous appliquiez déjà, mais visiblement [les patterns sont plus populaire lorsqu'on leur donne un nom sympa](https://fr.wikipedia.org/wiki/Plain_old_Java_object#Description) donc c'est ce que j'ai essayé de faire. Après est-ce que ce nom est sympa ? Je vous laisserai juger :smile:

Comme tout *bon* développeur java, j'utilise les `Collection` et les `stream` au quotidien pour le traitement de mes données.
Je vais vous montrer le genre d'implémentation qu'il m'arrive de rencontrer Je vais vous montrer à travers un exemple comment implémenter des traitements sur une `List` d'abord sans, puis ensuite avec le pattern LEP.
Voyons à travers un exemple le problème qu'on peut rencontrer si on ne fais pas attention.


Dans le code métier suivant la méthode `findCheapest()` parcourt la liste des articles pour retourner le moins cher :

```java
public record Item(double price) {
}

public interface ItemRepository {
    List<Item> findAll();
}

public class ItemService {
    
    private final ItemRepository repository;
    
    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public BigDecimal findCheapest() {
        return repository.findAll()
            .stream()
            .min(Comparator.comparing(Item::getPrice));
    }
}
```
Ici ItemService a pour reponsabilité de récupérer tous les articles, puis de la parcourir afin de déterminer lequel est le moins cher.

Ici la recherche de l'article le moins cher est implémenté directement dans la classe `ItemService`.
Si on souhaite réutiliser cette recherche ailleurs, il faudra donc passer par une instance de cette classe.

* Trop de responsabilité
* Maintenabilité plus compliquée
* Réutilisabilité plus compliquée.
On a ainsi une classe de test semblable à celle ci-dessous :
```java
public class ItemServiceTest {
    
    @Test
    void should_return_cheapest_item() {
        // Arrange
        var item1 = new Item(10.5);
        var item2 = new Item(9);
        var item3 = new Item(10);
        ItemRepository itemRepository = () -> List.of(item1, item2, item3);
        var itemService = new ItemService(itemRepository);
        // Act
        var cheapestItem = itemService.findCheapest();
        // Assert
        assertTrue(cheapestItem.isPresent());
        assertEquals(item2, cheapestItem.get());
    }
}
```

Ce qu'on remarque avec ce code c'est que la recherche de l'article est le moins cher n'est pas réutilisable avec une autre liste d'article.
On pourrait alors améliorer notre implémentation en séparant la récupération de tous les articles de la recherche de l'article le moins cher.
```java
public class ItemService {
    
    private final ItemRepository repository;
    
    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        return findCheapest(repository.findAll());
    }

    public Optional<Item> findCheapest(List<Item> items) {
        return items.stream().min(Comparator.comparing(Item::getPrice));
    }
}
```

Ainsi, si on a besoin de rechercher l'article le moins cher parmis une autre liste d'article on pourra réutiliser la méthode `public Optional<Item> findCheapest(List<Item> items)`
Ici la responsabilité de ItemService n'est d'implémenter de la logique métier, mais de s'appuyer sur les différents composants pour

Un bon indicateur pour savoir s'il faut mettre en place un LEP, c'est si vous faites un stream() sur une liste qui n'est pas un attribut de votre classe.
### Service
### Utils/Helper

## LEP
```java
public record Item(double price) {
}

public record Items(List<Item> items) {

    public Optional<Item> findCheapest() {
        return items.stream().min(Comparator.comparing(Item::getPrice));
    }
}

public interface ItemRepository {
    Items findAll();
}

public class ItemService {

    private final ItemRepository repository;

    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        return repository.findAll().findCheapest();
    }
}
```

```java
public class ItemsTest {

    @Test
    void should_return_cheapest_item() {
        // Arrange
        var item1 = new Item(10.5);
        var item2 = new Item(9);
        var item3 = new Item(10);
        var items = new Items(List.of(item1, item2, item3));
        // Act
        var cheapestItem = items.findCheapest();
        // Assert
        assertTrue(cheapestItem.isPresent());
        assertEquals(item2, cheapestItem.get());
    }
}
```

## Les tests

## Comment l'adopter ?

## Conclusion

