---
title: List Encapsulation Pattern
---
<!---
https://gist.github.com/rxaviers/7360908
-->
Pour mon premier article j'ai décidé de vous parler d'un pattern que j'ai nommé **LEP** pour **List Encapsulation Pattern**. Derrière cet acronymme se cache en réalité un concept très simple à comprendre et à adopter. D'ailleurs il est tout à fait possible que ce soit quelque chose que vous appliquiez déjà, mais visiblement [les patterns sont plus populaires lorsqu'on leur donne un nom sympa](https://fr.wikipedia.org/wiki/Plain_old_Java_object#Description). C'est ce que j'ai essayé de faire, vous me direz si j'ai réussi :smile:

Les développeurs java utilisent les `List` et les `Stream` au quotidien.
Ces classes permettent d'implémenter des algorithmes avec peu de lignes de code, mais parfois cette simplicité peut nous pousser à écrire du code au mauvais endroit. Rendant ainsi le code moins réutilisable, moins testable et donc moins maintenable.

Pour illustrer ces propos, voici un exemple dans lequel la recherche de l'article le moins cher d'une liste a été implémentée au mauvais endroit :
```java
public record Item(double price) {
}

public interface ItemRepository {
    List<Item> findAll();
}

public class ItemService {
    
    private final ItemRepository repository;
    
    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        return findCheapest(repository.findAll());
    }

    private Optional<Item> findCheapest(List<Item> items) {
        return items.stream().min(Comparator.comparing(Item::price));//Ici on recherche l'article le moins cher de la liste
    }
}
```

Pour l'instant il n'y a pas de problème. Le code est concis, clair et *testable*. Introduisons maintenant une nouvelle classe appelée `Cart` qui représente un panier contenant des articles :
```java
public record Cart(List<Item> items) {
}
```

On souhaite trouver l'article le moins cher de ce panier en réutilisant le code existant. Pour cela il faut :
* rendre public la méthode `private Optional<Item> findCheapest(List<Item> items)` de la classe `ItemService`
* avoir un objet `ItemService` qui lui même à besoin d'un objet `ItemRepository` pour être instancié
* ajouter une nouvelle méthode `findCheapestItem()` dans la classe `Cart` et appeler `ItemService`

On obtient donc le code suivant :
```java
public record Cart(List<Item> items) {

    public Optional<Item> findCheapestItem() {
        return new ItemService(null).findCheapest(items);
    }
}
```

Là, le bât blesse. Le code est étrange. On est obligé de passer un objet `ItemRepository` à `null` car `ItemService` en a besoin, mais pas la méthode `findCheapest` que nous appelons. Bref, heureusement dans la pratique il m'arrive plutôt de rencontrer ça :
```java
public record Cart(List<Item> items) {

    public Optional<Item> findCheapestItem() {
        return items.stream().min(Comparator.comparing(Item::price));
    }
}
```

Un bon `Ctrl+c Ctrl+v`, ce n'est guère mieux :scream:
Vu que ce n'est qu'une ligne de code, ça ne sera pas remonté comme duplication par les outils d'analyse de code. Pourtant il y a un problème de conception ici.

Alors très bien, mais comment on fait ?

Comme toujours dans le développemement, il y a plusieurs façon de s'y prendre. Nous allons voir ici comment le LEP va nous sortir de cette situation délicate :sunglasses:

L'idée consiste à introduire une nouvelle classe `Items` qui encapsule une `List<Item>`, ainsi les règles concernant cette liste seront centralisées dans cette nouvelle classe :
```java
public record Items(List<Item> items) {

    public Optional<Item> findCheapest() {
        return items.stream().min(Comparator.comparing(Item::price));
    }
}
```

Maintenant on peut appeler la classe `Items` à chaque fois qu'on souhaite rechercher l'article le moins cher d'une liste. On obtient alors le code final suivant :
```java
public record Item(double price) {
}

public record Items(List<Item> items) {

    public Optional<Item> findCheapest() {
        return items.stream().min(Comparator.comparing(Item::getPrice));
    }
}

public record Cart(Items items) {

    public Optional<Item> findCheapestItem() {
        return items.findCheapest();//L'appel vers le code existant est plus simple
    }
}

public interface ItemRepository {
    Items findAll();//On retourne maintenant des Items au lieu d'une List<Item>
}

public class ItemService {

    private final ItemRepository repository;

    public ItemService(ItemService repository) {
        this.repository = repository;
    }

    public Optional<Item> findCheapest() {
        return repository.findAll().findCheapest();//La recherche n'est plus implémentée dans le service
    }
}
```

Fini la duplication et le code bizarre :tada:

Ce pattern a aussi pour avantage de pouvoir être mise en place progressivement car on peut facilement faire des conversions entre `Items` et `List<Items>` comme ceci :
* Pour obtenir une `List<Item>` : `items.items()`
* Pour obtenir des `Items` : `new Items(liste)`

Pour terminer voici une règle pour détecter les situations dans lequel le pattern LEP peut s'appliquer :

Si on fait un `.stream()` sur une liste qui n'est pas un attribut de la classe, alors on peut mettre en place le pattern LEP.
